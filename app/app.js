/**
 * Created by xiewang on 7/13/16.
 */

'use strict';

import React from 'react';
import { Provider } from 'react-redux';
//import PushNotification from 'react-native-push-notification';

import configureStore from './store/configureStore';
import Main from './pages/navigator';

import {
    AlertIOS,
    NetInfo
} from 'react-native';
import { toast } from './utils/common';

const store = configureStore();

//PushNotification.configure({
//
//    // (optional) Called when Token is generated (iOS and Android)
//    onRegister: function(token) {
//        console.log( 'TOKEN:', token );
//        //AlertIOS.alert(
//        //    'Registered For Remote Push',
//        //    `Device Token: ${token}`,
//        //    [{
//        //        text: 'Dismiss',
//        //        onPress: null,
//        //    }]
//        //);
//    },
//
//    // (required) Called when a remote or local notification is opened or received
//    onNotification: function(notification) {
//        //PushNotification.cancelAllLocalNotifications()
//        //PushNotification.cancelLocalNotifications(notification);
//        return;
//        console.log( 'NOTIFICATION:', notification );
//        AlertIOS.alert(
//            'Push Notification Received',
//            'Alert message: ' + notification.message,
//            [{
//                text: 'Dismiss',
//                onPress: null,
//            }]
//        );
//    },
//
//    // ANDROID ONLY: GCM Sender ID (optional - not required for local notifications, but is need to receive remote push notifications)
//    senderID: "141041616019",
//
//    // IOS ONLY (optional): default: all - Permissions to register.
//    permissions: {
//        alert: true,
//        badge: true,
//        sound: true
//    },
//
//    // Should the initial notification be popped automatically
//    // default: true
//    popInitialNotification: false,
//
//    /**
//     * (optional) default: true
//     * - Specified if permissions (ios) and token (android and ios) will requested or not,
//     * - if not, you must call PushNotificationsHandler.requestPermissions() later
//     */
//    requestPermissions: true,
//});

class App extends React.Component {
    constructor(props) {
        super(props);
        this.state = {
            permissions:null
        }
    }

    componentWillMount() {
        //PushNotificationIOS.addEventListener('registrationError', this._onRegistrationError);

        //PushNotification.requestPermissions();

        NetInfo.fetch().done((reach) => {
            if(reach === 'none'){
                toast('网络连接不可用，请检查你的网络！');
            }
        });
    }

    componentWillUnmount() {
        //PushNotificationIOS.removeEventListener('registrationError', this._onRegistrationError);
    }

    componentDidMount() {
        console.log("component did mount");
        // local notification
        //PushNotification.localNotification({
        //    /* Android Only Properties */
        //    id: '0', // (optional) Valid unique 32 bit integer specified as string. default: Autogenerated Unique ID
        //    ticker: "您有剁手记本地通知", // (optional, audible announcement of this notification for accessibility services)
        //    autoCancel: true, // (optional) default: true; it means the notification should be canceled when it is clicked by the user
        //    largeIcon: "ic_launcher", // (optional) default: "ic_launcher"
        //    smallIcon: "ic_notification", // (optional) default: "ic_notification" with fallback for "ic_launcher"
        //    bigText: "欢迎使用剁手记，更多内容持续更新中", // (optional) default: "message" prop
        //    subText: "感谢您使用剁手记", // (optional) default: none
        //    color: "red", // (optional) default: system default
        //    vibrate: true, // (optional) default: true
        //    vibration: 300, // vibration length in milliseconds, ignored if vibrate=false, default: 1000
        //    //tag: 'some_tag', // (optional) add tag to message
        //    group: "com.duoshouji", // (optional) add group to message
        //    ongoing: false, // (optional) set whether this is an "ongoing" notification
        //
        //    /* iOS only properties */
        //    alertAction: 'view', // (optional) default: view
        //    //category: null, // (optional) default: null
        //    //userInfo: null, // (optional) default: null (object containing additional notification data)
        //
        //    /* iOS and Android properties */
        //    title: "剁手记本地通知准备就绪", // (optional, for iOS this is only used in apple watch, the title will be the app name on other iOS devices)
        //    message: "您有新的剁手记本地通知", // (required)
        //    playSound: false, // (optional) default: true
        //    soundName: 'default', // (optional) Sound to play when the notification is shown. Value of 'default' plays the default sound. It can be set to a custom sound such as 'android.resource://com.xyz/raw/my_sound'. It will look for the 'my_sound' audio file in 'res/raw' directory and play it. default: 'default' (default sound is played)
        //    number: 1, // (optional, deprecated in android API 24) Valid 32 bit integer specified as string. default: none (Cannot be zero)
        //    //repeatType: 'day', // (Android only) Repeating interval. Could be one of `week`, `day`, `hour`, `minute, `time`. If specified as time, it should be accompanied by one more parameter 'repeatTime` which should the number of milliseconds between each interval
        //    //actions: '["Yes", "No"]'  // (Android only) See the doc for notification actions to know more
        //});

        //PushNotification.localNotificationSchedule({
        //    title: "剁手记本地通知",
        //    message: "这是10秒之后自动触发的消息", // (required)
        //    date: new Date(Date.now() + (10 * 1000)) // in 10 secs
        //});
    }

    _onRegistrationError(error) {
        return;
        AlertIOS.alert(
            'Failed To Register For Remote Push',
            `Error (${error.code}): ${error.message}`,
            [{
                text: 'Dismiss',
                onPress: null,
            }]
        );
    }

    render() {
        return (
            <Provider store={store}>
                <Main />
            </Provider>
        );
    }
}

export default App;